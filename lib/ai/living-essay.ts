import { CallSummary } from '@/lib/db/schema';
import { createLivingEssay, getRecentEssays, createTidbits, associateTidbitsWithEssay } from '@/lib/db/living-essay';

interface EssaySection {
  heading: string;
  content: string;
}

interface Tidbit {
  type: string;
  content: string;
  description: string;
  relevanceScore: number;
}

interface GeneratedContent {
  sections: EssaySection[];
  tidbits: Tidbit[];
}

export async function generateFromCallSummary(callSummary: CallSummary): Promise<GeneratedContent> {
  if (!callSummary.clerkUserId) {
    throw new Error('Call summary must have a clerkUserId');
  }

  // Get recent essays for context
  const recentEssays = await getRecentEssays(callSummary.clerkUserId, 3);
  
  // Prepare the prompt with context
  const messages = [{
    role: "system",
    content: `You are an AI that generates living essays and insightful tidbits from conversation summaries. 
    The living essay should reflect the person's current state, thoughts, and growth.
    
    Previous essay versions (for context):
    ${recentEssays.map((essay) => 
      (essay.sections as EssaySection[]).map((section) => 
        `${section.heading}:\n${section.content}`
      ).join('\n\n')
    ).join('\n\n---\n\n')}
    
    Recent conversation summary:
    ${callSummary.summary || ''}
    
    Full transcript:
    ${callSummary.transcript || ''}
    
    Generate:
    1. A living essay with 1-3 sections that captures the current state
    2. 2-4 relevant tidbits that highlight key insights or patterns
    
    Format the response as JSON with:
    {
      "sections": [{"heading": string, "content": string}],
      "tidbits": [{
        "type": "Mood"|"Focus"|"Value"|"Tension"|"Joy"|"Future"|"Echo"|"Shift",
        "content": string,
        "description": string,
        "relevanceScore": number
      }]
    }`
  }];

  // Call Groq API
  const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.GROQ_API_KEY}`,
    },
    body: JSON.stringify({
      model: 'llama-3.3-70b-versatile',
      messages,
      temperature: 0.7,
      response_format: { type: "json_object" }
    }),
  });

  if (!response.ok) {
    const errorData = await response.text();
    throw new Error(`Failed to generate content from Groq: ${errorData}`);
  }

  const data = await response.json();
  
  if (!data.choices?.[0]?.message?.content) {
    throw new Error('Invalid response format from Groq');
  }

  let content: GeneratedContent;
  try {
    content = JSON.parse(data.choices[0].message.content);
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to parse JSON response from Groq: ${error.message}`);
    }
    throw new Error('Failed to parse JSON response from Groq');
  }

  // Validate the content structure
  if (!content.sections || !Array.isArray(content.sections) || !content.tidbits || !Array.isArray(content.tidbits)) {
    throw new Error('Invalid content structure generated by Groq');
  }

  // Store the essay and get its ID
  const essay = await createLivingEssay(callSummary.clerkUserId, content.sections);

  // Store the tidbits
  const storedTidbits = await createTidbits(callSummary.clerkUserId, content.tidbits);

  // Associate tidbits with the essay
  await associateTidbitsWithEssay(essay.id, storedTidbits.map(t => t.id));

  return content;
} 