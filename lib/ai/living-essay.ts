import { CallSummary } from '@/lib/db/schema';
import { createLivingEssay, getRecentEssays, createTidbits, associateTidbitsWithEssay } from '@/lib/db/living-essay';

interface EssaySection {
  heading: string;
  content: string;
}

interface Tidbit {
  type: string;
  content: string;
  description: string;
  relevanceScore: number;
}

interface GeneratedContent {
  sections: EssaySection[];
  tidbits: Tidbit[];
}

export async function generateFromCallSummary(callSummary: CallSummary): Promise<GeneratedContent> {
  if (!callSummary.clerkUserId) {
    throw new Error('Call summary must have a clerkUserId');
  }

  // Get recent essays for context
  const recentEssays = await getRecentEssays(callSummary.clerkUserId, 3);
  
  // Prepare the prompt with context
  const messages = [{
    role: "system",
    content: `The following is a transcript of a user speaking freely to Fred, reflecting on their inner life, dilemmas, observations, and aspirations. Your job is to transform this into a “Living Essay” — a lightly structured, evolving reflection that captures the **core tensions**, **emerging insights**, and **unspoken threads** running through their thoughts. This is not an academic essay or a bullet-point summary. It's an open-ended artifact of thought-in-progress — raw but readable, organized but not over-edited.

    Instructions:
      - Preserve the user's **original tone and voice** — keep it human, slightly informal, and reflective.
      - Organize the essay around the **central tensions or recurring themes** that show up across the transcript.
      - Use smooth transitions and connective language to reflect how the user's thoughts evolved over time.
      - Highlight any moments of clarity, contradiction, or deeper questioning — these are the lifeblood of a Living Essay.
      - You may gently paraphrase or tighten the language for readability, but do **not over-summarize or conclude**. The essay should feel like a process that's still unfolding.
      - Avoid generic summaries. Anchor everything in the user's unique language, metaphors, and phrasing when possible.
      - Close with an open-ended note, leaving space for continued reflection.
      - Tone: Introspective, thoughtful, unfinished by design
      - Each essay section should be 1-2 paragraphs long.
      - The tidbits should be 1-2 sentences long.
    
    Previous essay versions (for context):
    ${recentEssays.map((essay) => 
      (essay.sections as EssaySection[]).map((section) => 
        `${section.heading}:\n${section.content}`
      ).join('\n\n')
    ).join('\n\n---\n\n')}
    
    Recent conversation summary:
    ${callSummary.summary || ''}
    
    Full transcript:
    ${callSummary.transcript || ''}
    
    Generate:
    1. A living essay with 1-3 sections that captures the current state
    2. 2-4 relevant tidbits that highlight key insights or patterns
    
    Format the response as JSON with:
    {
      "sections": [{"heading": string, "content": string}],
      "tidbits": [{
        "type": "Mood"|"Focus"|"Value"|"Tension"|"Joy"|"Future"|"Echo"|"Shift",
        "content": string,
        "description": string,
        "relevanceScore": number
      }]
    }`
  }];

  // Call Groq API
  const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.GROQ_API_KEY}`,
    },
    body: JSON.stringify({
      model: 'llama-3.3-70b-versatile',
      messages,
      temperature: 0.7,
      response_format: { type: "json_object" }
    }),
  });

  if (!response.ok) {
    const errorData = await response.text();
    throw new Error(`Failed to generate content from Groq: ${errorData}`);
  }

  const data = await response.json();
  
  if (!data.choices?.[0]?.message?.content) {
    throw new Error('Invalid response format from Groq');
  }

  let content: GeneratedContent;
  try {
    content = JSON.parse(data.choices[0].message.content);
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to parse JSON response from Groq: ${error.message}`);
    }
    throw new Error('Failed to parse JSON response from Groq');
  }

  // Validate the content structure
  if (!content.sections || !Array.isArray(content.sections) || !content.tidbits || !Array.isArray(content.tidbits)) {
    throw new Error('Invalid content structure generated by Groq');
  }

  // Store the essay and get its ID
  const essay = await createLivingEssay(callSummary.clerkUserId, content.sections);

  // Store the tidbits
  const storedTidbits = await createTidbits(callSummary.clerkUserId, content.tidbits);

  // Associate tidbits with the essay
  await associateTidbitsWithEssay(essay.id, storedTidbits.map(t => t.id));

  return content;
} 